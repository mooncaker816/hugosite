+++
title = "寿星万年历的Go 语言实现（一）"
date = 2018-05-09T14:43:35+08:00
draft = false

# Tags and categories
# For example, use `tags = []` for no tags, or the form `tags = ["A Tag", "Another Tag"]` for one or more tags.
tags = ["万年历"]
categories = ["Golang"]

# Featured image
# Place your image in the `static/img/` folder and reference its filename below, e.g. `image = "example.jpg"`.
# Use `caption` to display an image caption.
#   Markdown linking is allowed, e.g. `caption = "[Image credit](http://example.org)"`.
# Set `preview` to `false` to disable the thumbnail in listings.
[header]
image = ""
caption = ""
preview = true

+++

<!--more-->

## ① 背景


​        由于要用到农历的节气信息，查阅资料发现，非天文算法实现的日历无法准确的获得节气的时间点，所以只能使用天文算法来推演。

​        通过度娘，我找到了由许剑伟先生开发的《寿星万年历》，该软件是一套开源的精准的年代跨度大的天文历法工具，有很多有趣的功能，感兴趣的同学可以自行搜索，在此感谢许先生的无私。

​	接下来就打算把这套算法以 Go 来实现：[Github](https://github.com/mooncaker816/go-calendar)

## ② 基本概念

1. **公历**（solar calendar）：公历中规定平年有365日，闰年366日。每年含有12个月。

   - **儒略历**（Julian calendar）: 在1582年10月4日以前, 规定每4年设置一个闰年，平均年长度为365.25天
   - **格里高利历**（Gregorian calendar）: 在1582年10月15日之后, 规定每400年97闰，平均年长度为365.2425天

     > 由于儒略历存在严重的“多闰”问题，到了1582年，公历跑快了10天左右，当时就人为调整了10天，并从此改用格里历。因此务必注意1582年10月4日（儒略历）的下一日为1582年10月15日（格里高利历）。也就是说1582年10月份少了10天。

2. **闰年** (leap year)

   - **儒略历**: 能被4整除的年份为闰年（产生多润的原因）
   - **格里高利历**: 能被4整除但不能被100整除的非世纪年 + 能被400整除的世纪年

3. **儒略日**（Julian Day）& **儒略日数**（Julian Day Number，JDN）

   - **儒略日数的计算**

     从[格林威治标准时间](https://baike.baidu.com/item/%E6%A0%BC%E6%9E%97%E5%A8%81%E6%B2%BB%E6%A0%87%E5%87%86%E6%97%B6%E9%97%B4)的中午开始，包含一个整天的时间，起点的时间（0日）回溯至[儒略历](https://baike.baidu.com/item/%E5%84%92%E7%95%A5%E5%8E%86)的公元前4713年1月1日中午12点（在[格里历](https://baike.baidu.com/item/%E6%A0%BC%E9%87%8C%E5%8E%86)是公元前4714年11月24日），这个日期是三种多年周期的共同起点，且是历史上最接近现代的一个起点。例如，2000年1月1日的[UT](https://baike.baidu.com/item/UT)12:00是儒略日2,451,545。

     > 设Y为给定年份，M为月份，D为该月日期（可以带小数）。
     >
     > 若M > 2，Y和M不变，若 M =1或2，以Y–1代Y，以M+12代M，换句话说，如果日期在1月或2月，则被看作是在前一年的13月或14月。
     >
     > 对格里高利历有 ：A = INT（Y/100） B = 2 - A + INT(A/4)
     >
     > 对儒略历，取 B = 0
     >
     > 要求的儒略日即为：JD = INT(365.25(Y+4716))+INT(30.6001(M+1))+D+B-1524.5
     >
     > 使用数值30.6取代30.6001才是正确的，但我们仍使用30.6001，以确保总能取得恰当的整数。事实上可用30.601甚至30.61来取代30.6001。例如，5乘30.6精确等于153，然而大多数计算机不能精确表示出30.6，这导致得出一个152.999 9998的结果，它的整数部分为152，如此算出的JD就不正确了。

     ​	[详细代码](https://github.com/mooncaker816/go-calendar/blob/master/greg.go)

   - **儒略日反推日期**

     > 将JD加上0.5，令 Z 为其整数部分，F 为尾数（小数）部分。
     >
     > 若 Z < 2299161，取A = Z
     >
     > 若 Z 大于等于2299 161，计算 α=INT((Z-1867216.25)/36524.25) ，A=Z+1+α-INT(α/4)
     >
     > 然后计算
     >
     > B = A+1524
     >
     > C = INT((B-122.1)/365.25)
     >
     > D = INT(365.25C)
     >
     > E = INT((B-D)/30.6001)
     >
     > 该月日期（带小数部分）则为：d = B - D - INT(30.6001E) + F
     >
     > 月份m为： 
     > IF E < 14 THEN m = E – 1 
     > IF E=14 or E=15 THEN m = E – 13 
     >
     > 年份为y：
     > IF m>2 THEN y = C – 4716
     > IF m =1 or m=2 THEN y = C – 4715
     >
     > 这个公式里求E时用的数30.6001不能代之以30.6，哪怕计算机没有先前所说的问题。否则，你得到的结果会是2月0日而不是1月31日，或者4月0日而不是3月31日。

     ​	[详细代码](https://github.com/mooncaker816/go-calendar/blob/master/julian.go)


4. **日期算星期**

     > 计算该日0时的儒略日，加上1.5，再除以7 ，所得余数将指示出星期几：若余数为0，则为星期日，1为星期一，2为星期二，3为星期三，4为星期四，5为星期五，6为星期六。 
     >
     > 儒略历到格里高利历的换算并不影响星期。因而，在1582年，10月4日星期四接下来的一天便是10月15日星期五。

     ​	[详细代码](https://github.com/mooncaker816/go-calendar/blob/master/greg.go)

   TBD。。。